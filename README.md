#Brain Burst

A Turn-based game server in Node.js

---

**A stable version is out, please check out `master` for deployment usage.**

---

##Installation

Because `websocket` may need local extension, so please run `npm install` or `npm install websocket` to compile this.

**Updated:** IT IS HIGHLY RECOMMEND TO RUN `rm -rf node_modules` and then run `npm install` under project folder.

##Configuration

The configuration file is `configuration.js`, when doing local debug, please use `NODE_ENV=development` environment, otherwise use `NODE_ENV=depolyment`

##Run

Please use `NODE_ENV=development node app.js` or `NODE_ENV=deployment node app.js` to run this app.

If you are using `WebStorm` as IDE, maybe you could just run it by `BrainBurst` running configuration.

##Design of this project

###Why choose this?

To create a turn-based game server in just a few weeks, NodeJS is a perfect choice. Although memory it consumed is relatively large.

###Overview

Node.js is used as server, there will be `CPU core number + 1` process dealing with server logic, the `1` is the master process, which response for forwarding message sent by workers to its destination; and the `CPU core number` process deal with the actually server work-flow.

MongoDB is used as a persistent storage for players data and their game data. Each worker holds a connection to mongo.

RedisDB is used as a global connection pool and a push storage, connection pool will be flushed each time server restart, but push notification will be stored on disk by dump file.

There is still not a workable solution here to deal with suddenly crash (DB was accidentally killed, power off, etc.,)

###Node.js logic

Connections will be dropped if they does not meet the requires mentioned here:

* Connection from remote clients should contains a specific protocol

* Connection who sends a binary data will be dropped

* `string` sent by client should be a valid `JSON` string, and contains a msg_id and a type

inter-process communication:

* when a user logged in, a `get_push` will be sent to master process, and master will check push db and get all unsent pushes and send to corresponding worker.

* when worker gets a `send_push`, it will try send it to user, if failed, it will send a `restore_push` message to master process and master will store it into redis.

* when a new push is generated by worker process, it will send a `new_push` message to master process, and master will try to send it to corresponding worker, and if failed, it will store this push into redis.

###MongoDB architecture

* player

    * `game`    string  specify which game it plays (not implemented yet)
    * `user_id` string  a unique uuid
    * `user_data`   string  a JSON string to store app specify data

* game_matches  **NOTE: the game here is a client defined string**

    * `match_id`    string  a unique uuid
    * `players`  array   an ordered array contains players' uuid, ordered by the time they join this game
    * `status`  string  this would be three different status :
        * `pending` waiting for player to join (not started)
        * `waiting` waiting for players to submit their game data (already started)
        * `end` someone has already leaves the game (can not be continued) **when `status` is `end` and `players` is an empty arrary, that means this match could be safely delete**
    * `match_data` string   a JSON string specified by client

###RedisDB architecture

* connection pool

    * key   user_id
    * value worker_pid

* Push

    * key   user_id
    * value an ordered list, ordered by push time

###Protocol

Please see `protocol.json` under this project.

###File architecture

`app.js` is the main file which handles its main logic, it will create worker (child) process by cluster to maintain WebSocket connection, and a master process to deal with inter-process communication.

Files under `libs` are just like there names, used for validation incoming JSON, build output JSON, and database connections.


